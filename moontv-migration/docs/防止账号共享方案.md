# é˜²æ­¢è´¦å·å…±äº«ï¼ˆä¸€æˆ·å¤šç”¨ï¼‰è§£å†³æ–¹æ¡ˆ

## é—®é¢˜æè¿°

ç”¨æˆ·è´­ä¹°ä¼šå‘˜åå¯èƒ½å­˜åœ¨ä»¥ä¸‹é—®é¢˜ï¼š
- ğŸ”´ åŒæ—¶åœ¨å¤šä¸ªè®¾å¤‡ä¸Šç™»å½•
- ğŸ”´ åˆ†äº«è´¦å·ç»™ä»–äººä½¿ç”¨
- ğŸ”´ ä¸€ä¸ªè´¦å·å¤šäººè½®æµä½¿ç”¨
- ğŸ”´ è´¦å·è¢«å€’å–æˆ–è½¬è®©

## è§£å†³æ–¹æ¡ˆå¯¹æ¯”

| æ–¹æ¡ˆ | éš¾åº¦ | æ•ˆæœ | ç”¨æˆ·ä½“éªŒ | æ¨èåº¦ |
|------|------|------|----------|--------|
| è®¾å¤‡æ•°é‡é™åˆ¶ | â­â­ | â­â­â­â­ | â­â­â­â­ | â­â­â­â­â­ |
| IPåœ°å€æ£€æµ‹ | â­â­â­ | â­â­â­ | â­â­â­ | â­â­â­ |
| åŒæ—¶åœ¨çº¿é™åˆ¶ | â­â­â­ | â­â­â­â­â­ | â­â­â­ | â­â­â­â­â­ |
| ç™»å½•é¢‘ç‡é™åˆ¶ | â­â­ | â­â­â­ | â­â­â­â­ | â­â­â­ |
| è®¾å¤‡æŒ‡çº¹è¯†åˆ« | â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­ | â­â­â­â­â­ |
| å¼‚å¸¸è¡Œä¸ºæ£€æµ‹ | â­â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­ |

## ğŸ¯ æ¨èæ–¹æ¡ˆï¼šè®¾å¤‡æ•°é‡é™åˆ¶ï¼ˆæœ€ç®€å•æœ‰æ•ˆï¼‰

### æ–¹æ¡ˆè¯´æ˜
é™åˆ¶ä¸€ä¸ªè´¦å·æœ€å¤šå¯ä»¥ç»‘å®šçš„è®¾å¤‡æ•°é‡ï¼Œä¾‹å¦‚ï¼š
- æ™®é€šä¼šå‘˜ï¼šæœ€å¤š2å°è®¾å¤‡
- é«˜çº§ä¼šå‘˜ï¼šæœ€å¤š3å°è®¾å¤‡
- å®¶åº­ä¼šå‘˜ï¼šæœ€å¤š5å°è®¾å¤‡

### å®ç°æ­¥éª¤

#### 1. åˆ›å»ºè®¾å¤‡è¡¨

```sql
-- database/user_devices.sql
CREATE TABLE IF NOT EXISTS user_devices (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    device_id TEXT NOT NULL,           -- è®¾å¤‡å”¯ä¸€æ ‡è¯†
    device_name TEXT,                  -- è®¾å¤‡åç§°ï¼ˆå¦‚ï¼šiPhone 13ã€Chromeæµè§ˆå™¨ï¼‰
    device_type TEXT,                  -- è®¾å¤‡ç±»å‹ï¼ˆmobile/desktop/tabletï¼‰
    platform TEXT,                     -- å¹³å°ï¼ˆios/android/windows/macï¼‰
    browser TEXT,                      -- æµè§ˆå™¨ä¿¡æ¯
    last_login_ip TEXT,                -- æœ€åç™»å½•IP
    last_login_time TEXT,              -- æœ€åç™»å½•æ—¶é—´
    first_seen TEXT NOT NULL,          -- é¦–æ¬¡ç»‘å®šæ—¶é—´
    is_active INTEGER DEFAULT 1,       -- æ˜¯å¦æ´»è·ƒ
    created_at TEXT DEFAULT (datetime('now')),
    UNIQUE(user_id, device_id)
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_user_devices_user_id ON user_devices(user_id);
CREATE INDEX idx_user_devices_device_id ON user_devices(device_id);
```

#### 2. å‰ç«¯ï¼šç”Ÿæˆè®¾å¤‡æŒ‡çº¹

åœ¨ `src/lib/device.ts` åˆ›å»ºè®¾å¤‡è¯†åˆ«å·¥å…·ï¼š

```typescript
// src/lib/device.ts
export function generateDeviceId(): string {
  // æ–¹æ¡ˆ1ï¼šä½¿ç”¨æµè§ˆå™¨æŒ‡çº¹ï¼ˆæ¨èï¼‰
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  if (ctx) {
    ctx.textBaseline = 'top';
    ctx.font = '14px Arial';
    ctx.fillText('device-fingerprint', 2, 2);
    const canvasData = canvas.toDataURL();
    return hashCode(canvasData);
  }

  // æ–¹æ¡ˆ2ï¼šä½¿ç”¨è®¾å¤‡ä¿¡æ¯ç»„åˆ
  const components = [
    navigator.userAgent,
    navigator.language,
    screen.width + 'x' + screen.height,
    new Date().getTimezoneOffset(),
    navigator.hardwareConcurrency || 0,
  ];
  
  return hashCode(components.join('|'));
}

function hashCode(str: string): string {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash;
  }
  return Math.abs(hash).toString(36);
}

export function getDeviceInfo() {
  const ua = navigator.userAgent;
  
  return {
    deviceId: generateDeviceId(),
    deviceName: getDeviceName(),
    deviceType: getDeviceType(),
    platform: getPlatform(),
    browser: getBrowser(),
  };
}

function getDeviceName(): string {
  const ua = navigator.userAgent;
  
  // æ£€æµ‹å…·ä½“è®¾å¤‡å‹å·
  if (/iPhone/.test(ua)) {
    const match = ua.match(/iPhone\s*(\w+)/);
    return match ? `iPhone ${match[1]}` : 'iPhone';
  }
  if (/iPad/.test(ua)) return 'iPad';
  if (/Android/.test(ua)) {
    const match = ua.match(/Android.*?;\s*([^;)]+)/);
    return match ? match[1] : 'Androidè®¾å¤‡';
  }
  
  return navigator.platform || 'æœªçŸ¥è®¾å¤‡';
}

function getDeviceType(): string {
  const ua = navigator.userAgent;
  if (/Mobile|Android|iPhone/i.test(ua)) return 'mobile';
  if (/iPad|Tablet/i.test(ua)) return 'tablet';
  return 'desktop';
}

function getPlatform(): string {
  const ua = navigator.userAgent;
  if (/iPhone|iPad|iPod/.test(ua)) return 'ios';
  if (/Android/.test(ua)) return 'android';
  if (/Windows/.test(ua)) return 'windows';
  if (/Mac/.test(ua)) return 'mac';
  if (/Linux/.test(ua)) return 'linux';
  return 'unknown';
}

function getBrowser(): string {
  const ua = navigator.userAgent;
  if (/Chrome/.test(ua) && !/Edge/.test(ua)) return 'Chrome';
  if (/Firefox/.test(ua)) return 'Firefox';
  if (/Safari/.test(ua) && !/Chrome/.test(ua)) return 'Safari';
  if (/Edge/.test(ua)) return 'Edge';
  return 'Other';
}
```

#### 3. å‰ç«¯ï¼šç™»å½•æ—¶ä¸ŠæŠ¥è®¾å¤‡ä¿¡æ¯

ä¿®æ”¹ç™»å½•é€»è¾‘ï¼š

```typescript
// src/app/login/page.tsx æˆ–ç™»å½•ç»„ä»¶
import { getDeviceInfo } from '@/lib/device';

async function handleLogin(username: string, password: string) {
  const deviceInfo = getDeviceInfo();
  
  const response = await fetch('/api/auth/login', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      username,
      password,
      device: deviceInfo, // æºå¸¦è®¾å¤‡ä¿¡æ¯
    }),
  });

  const data = await response.json();
  
  if (data.error === 'DEVICE_LIMIT_EXCEEDED') {
    // è®¾å¤‡æ•°é‡è¶…é™ï¼Œæ˜¾ç¤ºç®¡ç†è®¾å¤‡ç•Œé¢
    showDeviceManagementDialog(data.devices);
    return;
  }
  
  // ç™»å½•æˆåŠŸ
  if (response.ok) {
    // è·³è½¬åˆ°é¦–é¡µ
  }
}
```

#### 4. åç«¯ï¼šç™»å½•æ—¶éªŒè¯è®¾å¤‡æ•°é‡

```typescript
// src/app/api/auth/login/route.ts
import { db } from '@/lib/db';
import { getDeviceInfo } from '@/lib/device';

export async function POST(request: NextRequest) {
  const body = await request.json();
  const { username, password, device } = body;

  // 1. éªŒè¯ç”¨æˆ·åå¯†ç 
  const isValid = await db.verifyUser(username, password);
  if (!isValid) {
    return NextResponse.json({ error: 'ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯' }, { status: 401 });
  }

  // 2. æ£€æŸ¥è®¾å¤‡æ•°é‡é™åˆ¶
  const maxDevices = await getUserMaxDevices(username); // æ ¹æ®ä¼šå‘˜ç­‰çº§è·å–
  const userDevices = await db.getUserDevices(username);
  
  const currentDevice = userDevices.find(d => d.device_id === device.deviceId);
  
  if (!currentDevice && userDevices.length >= maxDevices) {
    // è®¾å¤‡æ•°é‡å·²è¾¾ä¸Šé™
    return NextResponse.json({
      error: 'DEVICE_LIMIT_EXCEEDED',
      message: `æ‚¨çš„è´¦å·æœ€å¤šåªèƒ½ç»‘å®š${maxDevices}å°è®¾å¤‡`,
      devices: userDevices,
    }, { status: 403 });
  }

  // 3. è®°å½•æˆ–æ›´æ–°è®¾å¤‡ä¿¡æ¯
  await db.upsertUserDevice({
    username,
    deviceId: device.deviceId,
    deviceName: device.deviceName,
    deviceType: device.deviceType,
    platform: device.platform,
    browser: device.browser,
    lastLoginIp: getClientIp(request),
    lastLoginTime: new Date().toISOString(),
  });

  // 4. ç”Ÿæˆtokenå¹¶ç™»å½•
  // ...çœç•¥ç™»å½•é€»è¾‘
  
  return NextResponse.json({ success: true });
}

// æ ¹æ®ä¼šå‘˜ç­‰çº§è·å–è®¾å¤‡æ•°é‡é™åˆ¶
async function getUserMaxDevices(username: string): Promise<number> {
  const subscription = await db.getUserSubscription(username);
  
  if (!subscription || subscription.status !== 'active') {
    return 2; // å…è´¹ç”¨æˆ·ï¼š2å°è®¾å¤‡
  }
  
  const plan = await db.getPlanById(subscription.plan_id);
  
  // ä»å¥—é¤ç‰¹æƒä¸­è§£æè®¾å¤‡æ•°é‡
  if (plan?.features) {
    const features = JSON.parse(plan.features);
    const deviceFeature = features.find((f: string) => f.includes('è®¾å¤‡'));
    if (deviceFeature) {
      const match = deviceFeature.match(/(\d+)/);
      if (match) return parseInt(match[1]);
    }
  }
  
  return 3; // é»˜è®¤ä¼šå‘˜ï¼š3å°è®¾å¤‡
}
```

#### 5. å‰ç«¯ï¼šè®¾å¤‡ç®¡ç†ç•Œé¢

åˆ›å»ºè®¾å¤‡ç®¡ç†ç»„ä»¶ï¼š

```typescript
// src/components/DeviceManagement.tsx
'use client';

import { useState, useEffect } from 'react';

export default function DeviceManagement() {
  const [devices, setDevices] = useState([]);

  useEffect(() => {
    fetchDevices();
  }, []);

  const fetchDevices = async () => {
    const res = await fetch('/api/user/devices');
    const data = await res.json();
    setDevices(data);
  };

  const handleRemoveDevice = async (deviceId: string) => {
    const confirmed = confirm('ç¡®å®šè¦è§£ç»‘è¿™å°è®¾å¤‡å—ï¼Ÿ');
    if (!confirmed) return;

    await fetch('/api/user/devices', {
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ deviceId }),
    });

    fetchDevices();
  };

  return (
    <div className="space-y-4">
      <h2 className="text-xl font-bold">æˆ‘çš„è®¾å¤‡</h2>
      
      <div className="grid gap-4">
        {devices.map((device: any) => (
          <div key={device.id} className="border rounded-lg p-4">
            <div className="flex items-center justify-between">
              <div>
                <h3 className="font-medium">{device.device_name}</h3>
                <p className="text-sm text-gray-500">
                  {device.platform} Â· {device.browser}
                </p>
                <p className="text-xs text-gray-400">
                  æœ€åç™»å½•ï¼š{new Date(device.last_login_time).toLocaleString()}
                </p>
              </div>
              
              <button
                onClick={() => handleRemoveDevice(device.device_id)}
                className="text-red-600 hover:text-red-800"
              >
                è§£ç»‘
              </button>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
```

## ğŸ”¥ è¿›é˜¶æ–¹æ¡ˆï¼šåŒæ—¶åœ¨çº¿é™åˆ¶

### åŸç†
ä½¿ç”¨ WebSocket æˆ–å¿ƒè·³æœºåˆ¶æ£€æµ‹åŒæ—¶åœ¨çº¿æ•°é‡ï¼Œå‘ç°è¶…é™æ—¶å¼ºåˆ¶ä¸‹çº¿æ—§è®¾å¤‡ã€‚

### å®ç°æ–¹æ¡ˆ

#### 1. ä½¿ç”¨å¿ƒè·³æ£€æµ‹

```typescript
// src/lib/heartbeat.ts
export class HeartbeatManager {
  private interval: NodeJS.Timeout | null = null;
  
  start() {
    // æ¯30ç§’å‘é€ä¸€æ¬¡å¿ƒè·³
    this.interval = setInterval(() => {
      this.sendHeartbeat();
    }, 30000);
    
    // é¦–æ¬¡ç«‹å³å‘é€
    this.sendHeartbeat();
  }
  
  stop() {
    if (this.interval) {
      clearInterval(this.interval);
    }
  }
  
  private async sendHeartbeat() {
    const deviceInfo = getDeviceInfo();
    
    try {
      const res = await fetch('/api/user/heartbeat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          deviceId: deviceInfo.deviceId,
          timestamp: Date.now(),
        }),
      });
      
      const data = await res.json();
      
      if (data.forceLogout) {
        // è¢«å¼ºåˆ¶ä¸‹çº¿
        alert('æ‚¨çš„è´¦å·åœ¨å…¶ä»–è®¾å¤‡ç™»å½•ï¼Œå½“å‰è®¾å¤‡å·²ä¸‹çº¿');
        window.location.href = '/login';
      }
    } catch (error) {
      console.error('Heartbeat failed:', error);
    }
  }
}
```

#### 2. åç«¯å¿ƒè·³å¤„ç†

```typescript
// src/app/api/user/heartbeat/route.ts
export async function POST(request: NextRequest) {
  const user = await getAuthUser(request);
  if (!user) {
    return NextResponse.json({ error: 'æœªç™»å½•' }, { status: 401 });
  }

  const { deviceId, timestamp } = await request.json();

  // æ›´æ–°è®¾å¤‡æœ€åæ´»è·ƒæ—¶é—´
  await redis.set(
    `device:${user.username}:${deviceId}`,
    timestamp,
    { ex: 60 } // 60ç§’åè¿‡æœŸ
  );

  // æ£€æŸ¥åœ¨çº¿è®¾å¤‡æ•°é‡
  const onlineDevices = await getOnlineDevices(user.username);
  const maxConcurrent = await getUserMaxConcurrentDevices(user.username);

  if (onlineDevices.length > maxConcurrent) {
    // è¶…è¿‡å¹¶å‘é™åˆ¶ï¼Œè¸¢æ‰æœ€æ—©ç™»å½•çš„è®¾å¤‡
    const deviceToKick = onlineDevices[0];
    
    if (deviceToKick.deviceId === deviceId) {
      // å½“å‰è®¾å¤‡æ˜¯æœ€æ—©çš„ï¼Œéœ€è¦è¢«è¸¢ä¸‹çº¿
      return NextResponse.json({ forceLogout: true });
    }
  }

  return NextResponse.json({ success: true });
}
```

## ğŸ“Š å…¶ä»–è¾…åŠ©æ–¹æ¡ˆ

### 1. IPåœ°å€å¼‚å¸¸æ£€æµ‹

```typescript
// æ£€æµ‹çŸ­æ—¶é—´å†…IPåœ°å€å˜åŒ–é¢‘ç¹
async function detectAbnormalIP(username: string, currentIP: string) {
  const recentIPs = await db.getRecentLoginIPs(username, 1); // æœ€è¿‘1å°æ—¶
  
  if (recentIPs.length > 5) {
    // 1å°æ—¶å†…ä»è¶…è¿‡5ä¸ªä¸åŒIPç™»å½•ï¼Œå¯èƒ½è´¦å·è¢«å…±äº«
    await sendAlertToAdmin({
      type: 'SUSPICIOUS_LOGIN',
      username,
      message: 'è´¦å·å¯èƒ½è¢«å…±äº«ä½¿ç”¨',
    });
  }
}
```

### 2. ç™»å½•æ—¶é—´åˆ†æ

```typescript
// æ£€æµ‹å¼‚å¸¸ç™»å½•æ—¶é—´æ¨¡å¼
async function detectAbnormalLoginPattern(username: string) {
  const logins = await db.getLoginHistory(username, 7); // æœ€è¿‘7å¤©
  
  // æ£€æµ‹æ˜¯å¦æœ‰åŒä¸€æ—¶é—´æ®µå¤šæ¬¡ç™»å½•
  const concurrent = logins.filter((login, index) => {
    const nextLogin = logins[index + 1];
    if (!nextLogin) return false;
    
    const timeDiff = Math.abs(
      new Date(login.time).getTime() - new Date(nextLogin.time).getTime()
    );
    
    return timeDiff < 60000; // 1åˆ†é’Ÿå†…
  });
  
  if (concurrent.length > 10) {
    // é¢‘ç¹åœ¨çŸ­æ—¶é—´å†…é‡å¤ç™»å½•ï¼Œå¯èƒ½æ˜¯è´¦å·å…±äº«
    return true;
  }
  
  return false;
}
```

### 3. è§‚çœ‹æ—¶é•¿ç»Ÿè®¡

```typescript
// æ£€æµ‹ä¸€å¤©å†…è§‚çœ‹æ—¶é•¿æ˜¯å¦å¼‚å¸¸
async function detectAbnormalWatchTime(username: string) {
  const watchTime = await db.getDailyWatchTime(username);
  
  if (watchTime > 24 * 60 * 60) {
    // ä¸€å¤©å†…è§‚çœ‹è¶…è¿‡24å°æ—¶ï¼Œæ˜æ˜¾æ˜¯å¤šäººå…±äº«
    return true;
  }
  
  return false;
}
```

## ğŸ¯ æ¨èå®æ–½ç»„åˆ

### åŸºç¡€ç‰ˆï¼ˆæ¨èæ–°é¡¹ç›®ï¼‰
âœ… è®¾å¤‡æ•°é‡é™åˆ¶ï¼ˆ2-3å°ï¼‰  
âœ… è®¾å¤‡ç®¡ç†ç•Œé¢  
âœ… ç™»å½•IPè®°å½•  

### æ ‡å‡†ç‰ˆï¼ˆæ¨èå•†ç”¨ï¼‰
âœ… è®¾å¤‡æ•°é‡é™åˆ¶ï¼ˆ2-3å°ï¼‰  
âœ… åŒæ—¶åœ¨çº¿é™åˆ¶ï¼ˆ1-2å°ï¼‰  
âœ… è®¾å¤‡ç®¡ç†ç•Œé¢  
âœ… IPåœ°å€ç›‘æ§  
âœ… å¼‚å¸¸ç™»å½•å‘Šè­¦  

### ä¸“ä¸šç‰ˆï¼ˆä¸¥æ ¼æ§åˆ¶ï¼‰
âœ… è®¾å¤‡æ•°é‡é™åˆ¶ï¼ˆ2-3å°ï¼‰  
âœ… åŒæ—¶åœ¨çº¿é™åˆ¶ï¼ˆ1å°ï¼‰  
âœ… è®¾å¤‡æŒ‡çº¹è¯†åˆ«  
âœ… å¤šç»´åº¦å¼‚å¸¸æ£€æµ‹  
âœ… æœºå™¨å­¦ä¹ è¯†åˆ«å…±äº«è¡Œä¸º  
âœ… è‡ªåŠ¨å°å·æœºåˆ¶  

## âš–ï¸ å¹³è¡¡ç”¨æˆ·ä½“éªŒ

### å®½æ¾ç­–ç•¥ï¼ˆæå‡ä½“éªŒï¼‰
- å…è®¸3-5å°è®¾å¤‡
- æä¾›è®¾å¤‡ç®¡ç†åŠŸèƒ½
- å…è®¸ç”¨æˆ·è‡ªè¡Œè§£ç»‘
- ä»…ç›‘æ§ä¸ä¸»åŠ¨å°å·

### ä¸¥æ ¼ç­–ç•¥ï¼ˆé˜²æ­¢æ»¥ç”¨ï¼‰
- é™åˆ¶2å°è®¾å¤‡
- é™åˆ¶1å°åŒæ—¶åœ¨çº¿
- å¼‚å¸¸è¡Œä¸ºè‡ªåŠ¨å°å·
- éœ€è¦å®¢æœè§£å°

## ğŸ’¡ æœ€ä½³å®è·µå»ºè®®

1. **é€æ­¥æ”¶ç´§**ï¼šå…ˆå®½æ¾åä¸¥æ ¼ï¼Œç»™ç”¨æˆ·é€‚åº”æœŸ
2. **é€æ˜å‘ŠçŸ¥**ï¼šæ˜ç¡®å‘ŠçŸ¥ç”¨æˆ·è®¾å¤‡é™åˆ¶è§„åˆ™
3. **ä¾¿æ·ç®¡ç†**ï¼šæä¾›ç®€å•çš„è®¾å¤‡ç®¡ç†ç•Œé¢
4. **åˆç†æé†’**ï¼šè®¾å¤‡è¶…é™æ—¶å‹å¥½æç¤ºï¼Œä¸è¦ç›´æ¥å°å·
5. **å®¢æœæ”¯æŒ**ï¼šæä¾›ç”³è¯‰æ¸ é“å¤„ç†è¯¯åˆ¤
6. **æ•°æ®åˆ†æ**ï¼šå®šæœŸåˆ†æè®¾å¤‡ä½¿ç”¨æ•°æ®ï¼Œä¼˜åŒ–ç­–ç•¥

## ğŸ“ å¥—é¤ç‰¹æƒç¤ºä¾‹

åœ¨åˆ›å»ºå¥—é¤æ—¶ï¼Œå¯ä»¥è¿™æ ·è®¾ç½®ç‰¹æƒï¼š

```
åŸºç¡€ä¼šå‘˜å¥—é¤ï¼ˆæœˆå¡ï¼‰ï¼š
- æœ€å¤š2å°è®¾å¤‡åŒæ—¶ç™»å½•
- é«˜æ¸…ç”»è´¨
- æ— å¹¿å‘Šè§‚çœ‹

æ ‡å‡†ä¼šå‘˜å¥—é¤ï¼ˆå­£å¡ï¼‰ï¼š
- æœ€å¤š3å°è®¾å¤‡åŒæ—¶ç™»å½•
- è¶…æ¸…ç”»è´¨
- ç¦»çº¿ä¸‹è½½

å®¶åº­ä¼šå‘˜å¥—é¤ï¼ˆå¹´å¡ï¼‰ï¼š
- æœ€å¤š5å°è®¾å¤‡åŒæ—¶ç™»å½•
- 4Kç”»è´¨
- åŒæ—¶è§‚çœ‹2å°è®¾å¤‡
```

---

**æ–‡æ¡£ç‰ˆæœ¬ï¼š** v1.0  
**æœ€åæ›´æ–°ï¼š** 2026-01-22  
**ç»´æŠ¤äººå‘˜ï¼š** MoonTV å¼€å‘å›¢é˜Ÿ
